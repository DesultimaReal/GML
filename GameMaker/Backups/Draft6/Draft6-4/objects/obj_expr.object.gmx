<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_expr</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Gravity variables
grav = 0;
gravdown = 0;
GravityRange = 50;
SuckRange = 25;
spd = 2;
popup = 0;
SideOfExit = round(random_range(5, -5));
//Rotation variables

orbit_angle = 500;
orbit_radius = 25;
orbit_speed = 10;

//Bouncing
t = 0;
increment = degtorad(65); //12 degrees, now converted to radians -- freq = 1 oscillation per second (1Hz)
amplitude = 15; // pixels of peak oscillation

//clone the y-position (or use x instead if you're doing horizontal oscillation)
xx = x;
yy = y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*ocsillation
t += increment;
shift = amplitude * sin(t);

//clone the movement from the object's speed and direction
xx += hspeed;
yy += vspeed;

//apply the shift
phy_position_x = xx + lengthdir_x(shift, direction + 90);
phy_position_y = yy + lengthdir_y(shift, direction + 90);
phy_position_x += 20;
*/
/*
if(instance_exists(obj_player)){
    targetx = obj_player.x;
    targety = obj_player.y;
    var dir = point_direction(x, y, targetx, targety);
speed = room_speed/6

time += increment;
shift = amplitude * sin(time);
var hspd = lengthdir_x(spd, dir);
var vspd = lengthdir_y(spd, dir);
phy_position_x += hspd;
phy_position_y += vspd;

//makes sure arrow face the way its travelling to make it slither

//x = x_pos + lengthdir_x(shift, direction + 90);
//y = y_pos + lengthdir_y(shift, direction + 90);

direction += shift;

image_angle = direction;
amplitude += 1;

}
*/
///scr_check_for_player()

//popupcode
//while(popup &lt; 100){
    /*if(popup &lt; 8){//Upward for half the time
        phy_position_y -= grav;
        grav--;
    }
    else{
        phy_position_y += grav;//Downward for half the time
        gravdown++;
    }
    //ONL code*/
    //phy_position_x += SideOfExit;
    //t += increment;
    //shift = abs(amplitude * sin(t))
    //shift = amplitude * sin(t);
    
    //clone the movement from the object's speed and direction
    //xx += hspeed;
    //yy += vspeed;
    
    //apply the shift
    //phy_position_x = xx + lengthdir_x(shift, direction + 90);
    //phy_position_y = yy + lengthdir_y(shift, direction + 90);
    
    
    //popup++;
//}

if(instance_exists(obj_player)){
    targetx = obj_player.x;
    targety = obj_player.y;
    var dir = point_direction(x, y, targetx, targety);
    var hspd = lengthdir_x(spd, dir);
    var vspd = lengthdir_y(spd, dir);
    var dis = point_distance(x,y,obj_player.x,obj_player.y);
    if(dis &lt; GravityRange) { //Between 50 and 25
        phy_position_x += hspd;
        phy_position_y += vspd;
    } //Orbit code
    else if(dis &lt;= SuckRange) { //Lower than Suctionrange
        //rotate
        orbit_angle +=orbit_speed;
        phy_position_x = obj_player.x +orbit_radius * cos(orbit_angle * pi/360);
        phy_position_y = obj_player.y +orbit_radius * sin(orbit_angle * pi/360);
        orbit_radius -= 1;
        //phy_position_x += hspd;
        //phy_position_y += vspd;
        
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>-1</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>1</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>4,4</point>
    <point>2,4</point>
  </PhysicsShapePoints>
</object>
